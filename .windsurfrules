## Coding Pattern Preferences
### General Principles
- Prefer simple solutions; avoid unnecessary complexity.
- Eliminate code duplication by checking for existing similar code and functionality.
- Ensure code functions correctly across development (dev), testing (test), and production (prod) environments.
- Only make requested changes or those that are well understood and directly related.
- When fixing bugs, first attempt to resolve them using existing patterns and technologies. If introducing a new approach, remove the old implementation to prevent duplication.

### Maintain a clean and well-organized codebase.
- Avoid writing scripts in files unless they are reusable.
- Keep files under 200–300 lines; refactor if they exceed this limit.
- Mock data only for tests; never use it in dev or prod environments.
- Never introduce stubbing or fake data that affects dev or prod.
- Do not overwrite .env files without explicit confirmation.

### Technical Stack
- Backend: Python
- Frontend: HTML, JavaScript
- Database: PostgreSQL (JSON file storage is not allowed)
- Environment Separation: Separate databases for dev, test, and prod.
- Search: Elasticsearch (hosted on elastic.co) with separate dev and prod indexes.
- Testing: Python-based test suite.

### Coding Workflow Preferences
- Focus on the specific areas of code relevant to the task.
- Avoid modifying unrelated code.
- Write comprehensive tests for all major functionalities.
- Do not make major architectural changes to working features unless explicitly required.
- Consider the impact of changes on other parts of the codebase.

### Project Rules
You are an expert in Python, FastAPI, LLM application development, and scalable API development.


### When refactoring or updating code:

- Do not break functionality.
- Do not remove or omit variables, functions, or features unless explicitly requested.
- Maintain all existing components while improving organization.
- Consolidate duplicate components only after verifying against original files.

### When fixing errors:

- Carefully analyze logs before making changes.
- Do not remove or alter existing functionality unless necessary.
- Ensure the code works exactly as before, with the error resolved.

### Key Development Principles
- Write concise, technical responses with accurate Python examples.
- Use functional and declarative programming; avoid unnecessary classes.
- Favor iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
- Follow lowercase with underscores for directories and files (e.g., routers/user_routes.py).
- Use named exports for routes and utility functions.
- Apply the "Receive an Object, Return an Object" (RORO) pattern.

### Python/FastAPI Guidelines
- Use def for pure functions and async def for asynchronous operations.
- Use type hints for all function signatures.
- Prefer Pydantic models over raw dictionaries for input validation.

### File Structure
- Exported routers
- Sub-routes
- Utilities
- Static content

### Models and schemas
- Avoid unnecessary curly braces in conditional statements.
- Use concise, one-line syntax for simple conditionals (e.g., if condition: do_something()).

### LLM Integration
Best practices:
- Async client initialization and management
- Structured prompt handling with templating
- Response streaming and chunking
- Vector storage for embeddings
- Response validation and parsing
- Rate limiting and retry logic

### Error Handling and Validation
- Handle errors and edge cases early in functions.
- Use early returns to prevent deeply nested if statements.
- Place the "happy path" last for better readability.
- Avoid unnecessary else statements; use guard clauses instead.
- Implement structured error logging with clear user messages.
- Use custom error types or error factories for consistency.
- Handle LLM-specific error cases:
  - Add LLM-specific error types
  - Implement fallbacks for failures
  - Handle context length limits
  - Validate response formats

### Dependencies
- Backend Framework: FastAPI
- Validation: Pydantic v2
- Database: Async libraries (e.g., asyncpg, aiomysql)
- ORM: SQLAlchemy 2.0 (if used)

### FastAPI-Specific Guidelines
- Use functional components and Pydantic models for input validation and response schemas.
- Use declarative route definitions with explicit return types.
- Use def for synchronous operations and async def for asynchronous ones.
- Prefer lifespan context managers over @app.on_event("startup") and @app.on_event("shutdown").
- Implement middleware for logging, error monitoring, and performance optimization.
- Optimize API performance using caching, async functions, and lazy loading.
- Use HTTPException for expected errors with proper HTTP status codes.

### Performance Optimization
- Use async operations for all database and external API calls.
- Cache frequently accessed data using Redis or in-memory stores.
- Optimize data serialization with Pydantic.
- Implement lazy loading for large datasets.
- Optimize LLM response handling:

### Cache responses
- Implement request batching
- Optimize context window usage
- Use streaming for long responses

### Scalability Best Practices
- Leverage FastAPI’s async capabilities for handling high traffic.
- Optimize backend services for high throughput and low latency.
- Use caching layers (e.g., Redis, Memcached) to reduce database load.
- Implement load balancing and service mesh solutions (e.g., Istio, Linkerd).

### Monitoring and Logging
- Use Prometheus and Grafana for monitoring and alerts.
- Implement structured logging for better observability.
- Integrate with centralized logging systems (e.g., ELK Stack, AWS CloudWatch).

### Track LLM operations:
- Token usage and cost
- Latency and failures
- Prompt-response pairs
- Vector store performance

### Key Conventions
- Use FastAPI’s dependency injection for shared resources.
- Prioritize API performance metrics (response time, latency, throughput).
- Avoid blocking operations in routes:
  - Prefer async and non-blocking workflows.
  - Use dedicated async functions for database and external API calls.
- Keep routes and dependencies structured for clarity.

### Reference Materials
- Follow OpenAI API documentation for model integrations.
- Refer to FastAPI documentation for best practices on data models, path operations, and middleware implementation.

